---
layout: default
---
<div class="chapter">
    <p class="abstract">
        <strong>Viua VM</strong> is a register-based virtual machine,
        programmable in high-level assembly;
        it is designed for <em>reliability</em>, <em>predictability</em>, <em>error-tolerance</em>, <em>concurrency</em> and
        <em>fine-grained control</em> over the software.
    </p>

    <p class="summary-first-part">
        The VM achieves its design goals by equipping programmers with
        a wide array of tools to craft their software.
    </p>

    <p class="summary-part">
        <strong>Reliability</strong> and <strong>error-tolerance</strong> is achieved by a robust
        system of <em>exception-based error handling</em>, and <em>process restarting</em>.
        When a program encounters an error there is a way of making it fail and abort, and
        if the process should be "permanent" it can be restarted by its watchdog.
        Exceptions and restarting make for a robust mechanism of handling failure and
        crafting more reliable software.
    </p>

    <p class="summary-part">
        <strong>Predictability</strong> and fine-grained <strong>control</strong> over software is
        achieved by separating programmers from the VM with only a thin layer of programming language, and
        providing programmers with an instruction set that makes it explicit what the program does.
    </p>
</div>

<div class="chapter">
    <h2> Features </h2>
    <p>
        Machine provides programmers with the following set of features ("WIP" means "Work In Progress", "PF" means "Planned Feature"):
        <ul>
            <li>compile-time checks of code perfomed by the assembler (WIP)</li>
            <li>separate compilation (assembler is able to produce "object files")</li>
            <li>static and dynamic linking</li>
            <li>hot-swapping dynamically linked modules (WIP)</li>

            <li>first-class functions</li>
            <li>arity-based function overloading</li>
            <li>mechanisms for static and dynamic dispatch of method calls</li>
            <li>coroutines (PF)</li>

            <li>process-based concurrency</li>
            <li>parallelism (given sufficient hardware resources)</li>
            <li>virtual process restarting on-failure (using user-programmed watchdog process)</li>

            <li>exception-based error handling (every object is throwable and catchable; VM catches C++ exceptions thrown in foreign functions)</li>
            <li>scope-based resource management (no Stop-The-World garbage collector)</li>
            <li>deferred calls</li>

            <li>non-blocking foreign function interface (requires at least two-core CPU)</li>
            <li>clean FFI for straightforward cooperation with C++ code</li>

            <li>no-copy function returns</li>
            <li>by-copy and by-move parameter passing to functions</li>
            <li>safe pointers for inside-VM objects</li>
            <li>move semantics for many instructions</li>
            <li>closures with multiple capture mechanisms (by-copy, by-reference, by-move)</li>
        </ul>
    </p>
</div>
